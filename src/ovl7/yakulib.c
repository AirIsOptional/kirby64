#include <ultra64.h>
#include <macros.h>
#include "yakulib.h"
#include "D_8004A7C4.h"

extern void print_error_stub(const char *fmt, ...);

extern const char D_801CE4A0[];
extern u16 D_800E77A0[];
extern u8 D_800E76C0[];
extern u8 D_800E7730[];
extern u8 D_800E7880[];

extern u32 D_800E8E60;
extern u32 D_800E0D50[];
extern u32 D_800E17D0[];
extern u32 D_800E6A10[];
extern u32 D_800E1D10[];

extern f32 D_800E4010[];
extern f32 D_800E41D0[];
extern f32 D_800E4390[];

extern f32 D_800E25D0[];
extern f32 D_800E2790[];
extern f32 D_800E2950[];

extern f32 D_801CE578;

#ifdef MIPS_TO_C
s32 func_801BBE50(s32 arg0, s32 arg1, u32 arg2) {
    s32 sp34;
    Vector sp28;
    Vector sp1C;
    s32 sp18;
    s32 temp_v0;
    s32 temp_v1;

    temp_v0 = func_800AEC08_ovl7(0x1F, 0x1E, 0x3C);
    if (temp_v0 == -1) {
        print_error_stub(&D_801CE4A0);
        return -1;
    }
    temp_v1 = temp_v0 * 4;
    D_800E0D50[temp_v0] = arg2;
    D_800E76C0[temp_v0] = 0xFF;
    D_800E7730[temp_v0] = 6;
    D_800E77A0[temp_v0] = 0;
    D_800E7880[temp_v0] = 0;

    // uses an sw to save a word, but the array is accesed like a byte array?
    *(&D_800E8E60 + temp_v0) = 1;
    sp18 = temp_v1;
    sp34 = temp_v0;
    D_800E1D10[temp_v1] = arg1;
    func_800A4794_ovl7(&sp28, arg0, temp_v0);
    D_800E25D0[temp_v0] = sp28.x;
    D_800E2790[temp_v0] = sp28.y;
    D_800E2950[temp_v0] = sp28.z;
    func_800A4DB8_ovl7(&sp1C, arg0);
    D_800E4010[temp_v1] = sp1C.x;
    D_800E41D0[temp_v0] = sp1C.y + D_801CE578;
    D_800E4390[temp_v1] = sp1C.z;
    D_800E17D0[temp_v0] = D_800E17D0[arg2];
    D_800E6A10[temp_v0] = D_800E6A10[arg2];
    return sp34;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BBE50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_801BBFE4_ovl7(s32 arg0) {
    s32 sp1C;
    s32 temp_ret;
    s32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;
    s32 phi_v1;

    temp_ret = func_800AEC08_ovl7(0x1F, 0x1E, 0x3C);
    temp_v0 = temp_ret;
    if (temp_v0 == -1) {
        print_error_stub(&D_801CE4C8, temp_v0);
        return -1;
    }
    *(&D_800E76C0 + temp_v0) = 0xFF;
    *(&D_800E7730 + temp_v0) = 6;
    temp_v1 = D_800E0D50[temp_v0];
    *(&D_800E77A0 + (temp_v0 * 2)) = arg0;
    D_800E7880[temp_v0] = 0;
    D_800E5F90[temp_v0] = D_800E5F90[temp_v1];
    D_800E6BD0[temp_v0] = D_800E6BD0[temp_v1];
    D_800E6A10[temp_v0] = D_800E6A10[temp_v1];
    if (temp_v1 == 0) {
        sp1C = temp_v0;
        D_800E2790[temp_v0] = func_8019B144_ovl7(temp_v0 * 4, temp_v1 * 4, temp_v0, D_800E5F90);
        phi_v1 = temp_v0 * 4;
    } else {
        D_800E2790[temp_v0] = D_800E2790[temp_v1];
        phi_v1 = temp_v0 * 4;
    }
    temp_v0_2 = *(D_800E0D50 + phi_v1);
    temp_v0_2 = temp_v0_2 * 4;
    *(&D_800E4010 + phi_v1) = *(&D_800E4010 + temp_v0_2);
    *(D_800E41D0 + phi_v1) = D_800E41D0[temp_v0_2];
    *(&D_800E4390 + phi_v1) = *(&D_800E4390 + temp_v0_2);
    *(&D_800E8E60 + phi_v1) = 0;
    *(&D_800E8220 + (D_8004A7C4->unk0 * 4)) = 1;
    sp1C = temp_ret;
    func_801BC1AC_ovl7(arg0, &D_800E4010, temp_ret, D_800E41D0);
    D_800D7090 = sp1C;
    return sp1C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BBFE4_ovl7.s")
#endif

void func_801BC1AC_ovl7(s32 arg0) {
    if (D_800E8220[D_8004A7C4->unk0] == 0) {
        D_801D0A58 = D_801CA6F4;
    } else {
        D_801D0A58 = D_801CA738;
    }
    D_801D0A58.unk1C = arg0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_801BC27C_ovl7(s32 arg0, s32 arg1) {
    s32 sp1C;
    s32 temp_ret;
    s32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;
    s32 phi_v1;

    temp_ret = func_800AEC08_ovl7(0x1F, 0x1E, 0x3C);
    temp_v0 = temp_ret;
    if (temp_v0 == -1) {
        print_error_stub(&D_801CE4F4, temp_v0);
        return -1;
    }
    *(&D_800E76C0 + temp_v0) = 0xFF;
    *(&D_800E7730 + temp_v0) = 6;
    temp_v1 = D_800E0D50[temp_v0];
    *(&D_800E77A0 + (temp_v0 * 2)) = arg0;
    D_800E7880[temp_v0] = arg1;
    D_800E5F90[temp_v0] = D_800E5F90[temp_v1];
    D_800E6BD0[temp_v0] = D_800E6BD0[temp_v1];
    D_800E6A10[temp_v0] = D_800E6A10[temp_v1];
    if (temp_v1 == 0) {
        sp1C = temp_v0;
        D_800E2790[temp_v0] = func_8019B144_ovl7(temp_v0 * 4, temp_v1 * 4, temp_v0, D_800E5F90);
        phi_v1 = temp_v0 * 4;
    } else {
        D_800E2790[temp_v0] = D_800E2790[temp_v1];
        phi_v1 = temp_v0 * 4;
    }
    temp_v0_2 = *(D_800E0D50 + phi_v1);
    temp_v0_2 = temp_v0_2 * 4;
    *(&D_800E4010 + phi_v1) = *(&D_800E4010 + temp_v0_2);
    *(D_800E41D0 + phi_v1) = D_800E41D0[temp_v0_2];
    *(&D_800E4390 + phi_v1) = *(&D_800E4390 + temp_v0_2);
    *(&D_800E8E60 + phi_v1) = 0;
    *(&D_800E8220 + (D_8004A7C4->unk0 * 4)) = 1;
    sp1C = temp_ret;
    func_801BC44C_ovl7(arg0, &D_800E4010, temp_ret, D_800E41D0);
    D_800D7090 = sp1C;
    return sp1C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BC27C_ovl7.s")
#endif


void func_801BC44C_ovl7(s32 arg0) {
    D_801CE750 = D_801C7DDC;
    D_801CE750.unk1C = D_801CD820[arg0];
    if (D_800E8220[D_8004A7C4->unk0] == 0) {
        D_801D0A38 = D_801CA7DC;
    } else {
        D_801D0A38 = D_801CA7FC;
    }
    D_801D0A38.unk1C = arg0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_801BC580_ovl7(s32 arg0) {
    s32 sp1C;
    s32 temp_ret;
    s32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;
    s32 phi_v1;

    temp_ret = func_800AEC08_ovl7(0x1F, 0x1E, 0x3C);
    temp_v0 = temp_ret;
    if (temp_v0 == -1) {
        print_error_stub(&D_801CE520, temp_v0);
        return -1;
    }
    *(&D_800E76C0 + temp_v0) = 0xFF;
    *(&D_800E7730 + temp_v0) = 6;
    temp_v1 = D_800E0D50[temp_v0];
    *(&D_800E77A0 + (temp_v0 * 2)) = arg0 + 0x24;
    D_800E7880[temp_v0] = 0;
    D_800E5F90[temp_v0] = D_800E5F90[temp_v1];
    D_800E6BD0[temp_v0] = D_800E6BD0[temp_v1];
    D_800E6A10[temp_v0] = D_800E6A10[temp_v1];
    if (temp_v1 == 0) {
        sp1C = temp_v0;
        D_800E2790[temp_v0] = func_8019B144_ovl7(temp_v0 * 4, temp_v1 * 4, temp_v0, D_800E5F90);
        phi_v1 = temp_v0 * 4;
    } else {
        D_800E2790[temp_v0] = D_800E2790[temp_v1];
        phi_v1 = temp_v0 * 4;
    }
    temp_v0_2 = *(D_800E0D50 + phi_v1);
    temp_v0_2 = temp_v0_2 * 4;
    *(&D_800E4010 + phi_v1) = *(&D_800E4010 + temp_v0_2);
    *(D_800E41D0 + phi_v1) = D_800E41D0[temp_v0_2];
    *(&D_800E4390 + phi_v1) = *(&D_800E4390 + temp_v0_2);
    *(&D_800E8E60 + phi_v1) = 0;
    sp1C = temp_ret;
    func_801BC72C_ovl7(arg0, &D_800E4010, temp_ret, D_800E41D0);
    D_800D7090 = sp1C;
    return sp1C;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BC580_ovl7.s")
#endif


void func_801BC72C_ovl7(s32 arg0) {
    D_801CE770 = D_801C7E84;
    D_801CE770.unk1C = D_801CD820[arg0];
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
s32 func_801BC794_ovl7(s32 arg0) {
    s32 sp1C;
    f32 *temp_a2;
    s32 temp_ret;
    s32 temp_v0;
    u32 temp_a0;
    u32 temp_v1;
    s32 phi_a0;
    f32 *phi_a2;

    temp_ret = func_800AEC08_ovl7(0x1C, 0x1E, 0x3C);
    temp_v0 = temp_ret;
    if (temp_v0 == -1) {
        print_error_stub(&D_801CE54C, temp_v0);
        return -1;
    }
    *(&D_800E76C0 + temp_v0) = 0xFF;
    *(&D_800E7730 + temp_v0) = 3;
    temp_a0 = D_800E0D50[temp_v0];
    *(&D_800E77A0 + (temp_v0 * 2)) = 8;
    D_800E7880[temp_v0] = arg0;
    D_800E5F90[temp_v0] = D_800E5F90[temp_a0];
    D_800E6BD0[temp_v0] = D_800E6BD0[temp_a0];
    D_800E6A10[temp_v0] = D_800E6A10[temp_a0];
    if (temp_a0 == 0) {
        sp1C = temp_v0;
        temp_a2 = &D_800E2790[temp_v0];
        *temp_a2 = func_8019B144_ovl7(temp_a0, temp_a0 * 4, D_800E5F90, temp_v0);
        phi_a0 = temp_v0 * 4;
        phi_a2 = temp_a2;
    } else {
        D_800E2790[temp_v0] = D_800E2790[temp_a0];
        phi_a0 = temp_v0 * 4;
        phi_a2 = &D_800E2790[temp_v0];
    }
    temp_v1 = *(D_800E0D50 + phi_a0);
    temp_v1 = temp_v1 * 4;
    *(&D_800E4010 + phi_a0) = *(&D_800E4010 + temp_v1);
    *(D_800E41D0 + phi_a0) = D_800E41D0[temp_v1];
    *(&D_800E4390 + phi_a0) = *(&D_800E4390 + temp_v1);
    *(&D_800E8E60 + phi_a0) = *(&D_800E8E60 + temp_v1);
    *(D_800E25D0 + phi_a0) = D_800E25D0[temp_v1];
    *phi_a2 = *(D_800E2790 + temp_v1);
    *(D_800E2950 + phi_a0) = D_800E2950[temp_v1];
    return temp_ret;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BC794_ovl7.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
Failed to decompile function func_801BC978_ovl7:

Unable to determine jump table for jr instruction.

There must be a read of a variable in the same block as
the instruction, which has a name starting with "jtbl".
#else
GLOBAL_ASM("asm/non_matchings/ovl7/ovl7_15/func_801BC978_ovl7.s")
#endif
