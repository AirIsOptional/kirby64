#include <ultra64.h>
#include <macros.h>

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
Failed to decompile function func_800BBBA0:

Found jr instruction, but the corresponding jump table is not provided.

Please pass a --rodata flag to mips_to_c, pointing to the right .s file.

(You might need to pass --goto and --no-andor flags as well,
to get correct control flow for non-jtbl switch jumps.)
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_12/func_800BBBA0.s")
#endif

#include "ovl1_12.h"

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void *func_800BBC6C(void) {
    s32 temp_t4;
    u32 temp_t0;
    u32 temp_t2;
    u32 temp_t8;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_v0;
    void *temp_v1;
    void *phi_v1;
    void *phi_v0;

    D_800ED4EC = 0;
    D_800ED4F4 = 0;
    seed_rng(D_800ED4E0->unk0);
    temp_a1 = D_800ED4E0;
    D_800BE4EC = temp_a1->unk4;
    temp_t8 = temp_a1->unk8;
    D_800BE52C = temp_t8;
    D_800BE500 = temp_t8;
    temp_t0 = temp_a1->unkC;
    D_800BE530 = temp_t0;
    D_800BE504 = temp_t0;
    temp_t2 = temp_a1->unk10;
    D_800BE534 = temp_t2;
    D_800BE508 = temp_t2;
    temp_t4 = temp_a1->unk14;
    D_800BE538 = temp_t4;
    D_800BE50C = temp_t4;
    D_800BE4FC = temp_a1->unk1C;
    gKirbyLives = temp_a1->unk20;
    gKirbyHp = temp_a1->unk24;
    D_800D6E54 = temp_a1->unk28;
    gKirbyStars = temp_a1->unk2C;
    D_800D6E64 = temp_a1->unk30;
    D_800D6BB0 = temp_a1->unk34;
    set_soft_rng_seed(temp_a1->unk38);
    temp_a1_2 = D_800ED4E0;
    phi_v1 = temp_a1_2;
    phi_v0 = &D_800D6E20;
loop_1:
    temp_v0 = phi_v0 + 4;
    temp_v1 = phi_v1 + 4;
    temp_v0->unk-4 = phi_v1->unk40;
    temp_v0->unk-3 = temp_v1->unk3D;
    temp_v0->unk-2 = temp_v1->unk3E;
    temp_v0->unk-1 = temp_v1->unk3F;
    phi_v1 = temp_v1;
    phi_v0 = temp_v0;
    if (temp_v0 != D_800D6E30) {
        goto loop_1;
    }
    D_800D6F38 = temp_a1_2->unk3C;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_12/func_800BBC6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
void func_800BBDC4(void) {
    s32 temp_a0;
    s32 temp_t4;
    s32 temp_t8;
    s32 temp_v1;
    u16 temp_a1;
    u16 temp_a1_2;
    u16 temp_a1_3;
    void *temp_a0_2;
    u16 phi_t0;
    u16 phi_a3;
    u16 phi_a2;

    temp_v1 = D_800ED4EC;
    D_80048F20[2] = 0;
    D_80048F20[1] = 0;
    D_80048F20->unk0 = 0;
    if (temp_v1 < 0) {
        D_800BE4F8 = 2;
        D_800D6F38 = 0;
        return;
    }
    temp_t8 = D_800ED4F4 - 1;
    D_800ED4F4 = temp_t8;
    if (temp_t8 <= 0) {
        temp_a0 = D_800ED4E0;
        temp_t4 = temp_v1 + 1;
        temp_a1 = (temp_a0 + (temp_v1 * 2))->unk100;
        D_800ED4EC = temp_t4;
        if ((temp_a1 & 0xE000) != 0) {
            D_800ED4EC = temp_t4 + 1;
        }
        if ((temp_a1 & 0x1C00) != 0) {
            D_800ED4EC = D_800ED4EC + 1;
        }
        if ((temp_a1 & 0x380) != 0) {
            D_800ED4EC = D_800ED4EC + 1;
        }
        temp_a1_2 = (temp_a0 + (D_800ED4EC * 2))->unk100;
        if (temp_a1_2 == 0xFFFF) {
            D_800ED4EC = -1;
            return;
        }
        D_800ED4F4 = temp_a1_2 & 0x7F;
    }
    temp_a0_2 = D_800ED4E0 + (D_800ED4EC * 2);
    temp_a1_3 = temp_a0_2->unk100;
    phi_t0 = 0;
    if ((temp_a1_3 & 0x8000) != 0) {
        phi_t0 = temp_a0_2->unk102;
    }
    phi_a3 = 0;
    if ((temp_a1_3 & 0x4000) != 0) {
        phi_a3 = temp_a0_2->unk102;
    }
    phi_a2 = 0;
    if ((temp_a1_3 & 0x2000) != 0) {
        phi_a2 = temp_a0_2->unk102;
    }
    if ((temp_a1_3 & 0x1000) != 0) {
        phi_t0 = temp_a0_2->unk104;
    }
    if ((temp_a1_3 & 0x800) != 0) {
        phi_a3 = temp_a0_2->unk104;
    }
    if ((temp_a1_3 & 0x400) != 0) {
        phi_a2 = temp_a0_2->unk104;
    }
    if ((temp_a1_3 & 0x200) != 0) {
        phi_t0 = temp_a0_2->unk106;
    }
    if ((temp_a1_3 & 0x100) != 0) {
        phi_a3 = temp_a0_2->unk106;
    }
    if ((temp_a1_3 & 0x80) != 0) {
        phi_a2 = temp_a0_2->unk106;
    }
    D_80048F20->unk0 = phi_t0;
    D_80048F20[1] = phi_a3;
    D_80048F20[2] = phi_a2;
    if ((phi_t0 & 0x80) != 0) {
        D_80048F20->unk9 = 0x40;
    }
    if ((phi_t0 & 0x40) != 0) {
        D_80048F20->unk9 = -0x40;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_12/func_800BBDC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3ec45aadfc2cb619035fb802d88c52eacfab0326
Failed to decompile function func_800BBF60:

Found jr instruction, but the corresponding jump table is not provided.

Please pass a --rodata flag to mips_to_c, pointing to the right .s file.

(You might need to pass --goto and --no-andor flags as well,
to get correct control flow for non-jtbl switch jumps.)
#else
GLOBAL_ASM("asm/non_matchings/ovl1/ovl1_12/func_800BBF60.s")
#endif
