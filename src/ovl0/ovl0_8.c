#include <ultra64.h>
#include <macros.h>

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80020F40(s32 arg0, s32 arg1, s32 arg2, ? arg3) {
    s32 temp_a2;
    void *temp_a1;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_a3_3;
    void *temp_v1;
    void *phi_a0;
    void *phi_v1;
    void *phi_v0;
    void *phi_v0_2;
    s32 phi_a2;
    void *phi_v0_3;

    if (arg2 >= 0) {
        if (arg2 < 0x11) {
            temp_a1 = (arg2 << 5) + &D_8003F440;
            if (*temp_a1 == 0) {
                phi_v0 = gDisplayListHead;
            } else {
                temp_a3 = gDisplayListHead;
                temp_a3->unk0 = (s32) ((((((s32) ((D_8003F3C8 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | ((((s32) ((arg1 + D_8003F3CC) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                temp_a3->unk4 = (s32) (((((s32) ((D_8003F3C0 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | ((((s32) ((arg1 + D_8003F3C4) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                phi_v0 = gDisplayListHead + 8;
            }
            phi_a0 = temp_a1 + 4;
            phi_v1 = &D_8003F3D0;
            phi_a2 = 1;
loop_6:
            temp_a2 = phi_a2 + 2;
            phi_v0_2 = phi_v0;
            if (phi_a0->unk0 != 0) {
                temp_a3_2 = phi_v0;
                temp_a3_2->unk0 = (s32) ((((((s32) ((phi_v1->unk8 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | ((((s32) ((arg1 + phi_v1->unkC) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                temp_a3_2->unk4 = (s32) (((((s32) ((phi_v1->unk0 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | ((((s32) ((arg1 + phi_v1->unk4) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                phi_v0_2 = phi_v0 + 8;
            }
            temp_v1 = phi_v1 + 0x10;
            phi_v0_3 = phi_v0_2;
            if (phi_a0->unk4 != 0) {
                temp_a3_3 = phi_v0_2;
                temp_a3_3->unk0 = (s32) ((((((s32) ((temp_v1->unk8 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | 0xF6000000) | ((((s32) ((arg1 + temp_v1->unkC) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                temp_a3_3->unk4 = (s32) (((((s32) ((temp_v1->unk0 + arg0) * D_8004A508) / 0x140) & 0x3FF) << 0xE) | ((((s32) ((arg1 + temp_v1->unk4) * D_8004A50C) / 0xF0) & 0x3FF) * 4));
                phi_v0_3 = phi_v0_2 + 8;
            }
            temp_v1 = temp_v1 + 0x10;
            phi_a0 = (phi_a0 + 4) + 4;
            phi_v1 = temp_v1;
            phi_v0 = phi_v0_3;
            phi_a2 = temp_a2;
            if (temp_a2 != 7) {
                goto loop_6;
            }
            D_80096520 = temp_v1;
            gDisplayListHead = phi_v0_3;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80020F40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function func_80021444:

Label L800215AC_ovl0_before refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).

This label was auto-generated as the target for a branch-likely
instruction (e.g. beql); you can also try to turn that into a non-likely
branch if that's equivalent in this context, i.e., if it's okay to
execute its delay slot unconditionally.
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021444.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800215F0(s32 arg4) {
    func_80021444(0, arg4);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800215F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80021618(f32 arg2, s32 arg4, s32 arg5) {
    func_80021444(arg2, (s32) (((arg4 * 4) + 0x80040000)->unk-9A0 * arg2), arg4, arg5);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021618.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_80021668(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    arg0->unk0 = (s32) ((((((u32) (D_8004A508 * arg3) / 0x140U) & 0x3FF) << 0xE) | 0xF6000000) | ((((u32) (arg4 * D_8004A50C) / 0xF0U) & 0x3FF) * 4));
    arg0->unk4 = (s32) (((((u32) (D_8004A508 * arg1) / 0x140U) & 0x3FF) << 0xE) | ((((u32) (arg2 * D_8004A50C) / 0xF0U) & 0x3FF) * 4));
    return &D_8004A508;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021668.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80021764(void *arg0) {
    s32 temp_s0_2;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 temp_v1_3;
    void *temp_s0;
    void *temp_s1;
    void *temp_s1_10;
    void *temp_s1_11;
    void *temp_s1_12;
    void *temp_s1_13;
    void *temp_s1_14;
    void *temp_s1_2;
    void *temp_s1_3;
    void *temp_s1_4;
    void *temp_s1_5;
    void *temp_s1_6;
    void *temp_s1_7;
    void *temp_s1_8;
    void *temp_s1_9;
    void *temp_s3;
    void *temp_s3_2;
    void *temp_s3_3;
    u32 phi_v0;
    u32 phi_v0_2;
    u32 phi_v0_3;
    s32 phi_s0;

    func_8001663C(&gDisplayListHead, arg0->unk3C, 0, arg0);
    temp_s1 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1 + 8);
    temp_s1->unk4 = 0;
    temp_s1->unk0 = 0xE7000000;
    temp_s1_2 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_2 + 8);
    temp_s1_2->unk4 = 0x300000;
    temp_s1_2->unk0 = 0xE3000A01;
    temp_s1_3 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_3 + 8);
    temp_s1_3->unk4 = 0;
    temp_s1_3->unk0 = 0xE200001C;
    temp_s0 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s0 + 8);
    temp_s0->unk0 = 0xF7000000;
    temp_s0->unk4 = func_800078F0(0xFF0000FF);
    func_80021618(0x28, 0x15, (f32) (u32) D_8004A430 * 0.00390625f, 3, 2, 1);
    func_80021618(0x4B, 0x15, (f32) (u32) D_8004A434 * 0.00390625f, 3, 2, 1);
    func_80021618(0x6E, 0x15, (f32) (u32) D_80048C74 * 0.00390625f, 3, 2, 1);
    func_80021618(0x9B, 0x15, ((f32) (u32) D_8004A430 * 0.00390625f) + ((f32) (u32) D_8004A434 * 0.00390625f), 3, 2, 1);
    func_80021618(0xD7, 0x15, (f32) (u32) D_80095DC0 * 0.00390625f, 3, 2, 1);
    func_80021618(0xFA, 0x15, (f32) (u32) D_80048C78 * 0.00390625f, 3, 2, 1);
    temp_s1_4 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_4 + 8);
    temp_s1_4->unk4 = 0;
    temp_s1_4->unk0 = 0xE7000000;
    temp_v1 = (u32) D_8004A430 >> 2;
    phi_v0 = temp_v1;
    if (temp_v1 >= 0x101U) {
        phi_v0 = 0x100U;
    }
    temp_s1_5 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_5 + 8);
    func_80021668(temp_s1_5, 0x3E, 0x1F, phi_v0 + 0x3E, 0x20);
    temp_s1_6 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_6 + 8);
    temp_s1_6->unk4 = 0;
    temp_s1_6->unk0 = 0xE7000000;
    temp_s3 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s3 + 8);
    temp_s3->unk0 = 0xF7000000;
    temp_s3->unk4 = func_800078F0(0xFF00FFFF);
    temp_v1_2 = (u32) D_8004A434 >> 2;
    if (temp_v1_2 >= 0x101U) {
        phi_v0_2 = 0x100U;
    } else {
        phi_v0_2 = temp_v1_2;
    }
    temp_s1_7 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_7 + 8);
    func_80021668(temp_s1_7, 0x3E, 0x21, phi_v0_2 + 0x3E, 0x22);
    temp_s1_8 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_8 + 8);
    temp_s1_8->unk4 = 0;
    temp_s1_8->unk0 = 0xE7000000;
    temp_s3_2 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s3_2 + 8);
    temp_s3_2->unk0 = 0xF7000000;
    temp_s3_2->unk4 = func_800078F0(0xFF00FF);
    temp_v1_3 = (u32) D_80048C74 >> 2;
    if (temp_v1_3 >= 0x101U) {
        phi_v0_3 = 0x100U;
    } else {
        phi_v0_3 = temp_v1_3;
    }
    temp_s1_9 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_9 + 8);
    func_80021668(temp_s1_9, 0x3E, 0x23, phi_v0_3 + 0x3E, 0x24);
    temp_s1_10 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_10 + 8);
    temp_s1_10->unk4 = 0;
    temp_s1_10->unk0 = 0xE7000000;
    temp_s3_3 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s3_3 + 8);
    temp_s3_3->unk0 = 0xF7000000;
    temp_s3_3->unk4 = func_800078F0(0x101010FF);
    phi_s0 = 0x3E;
loop_9:
    temp_s1_11 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_11 + 8);
    func_80021668(temp_s1_11, phi_s0, 0x1F, phi_s0, 0x24);
    temp_s0_2 = phi_s0 + 0x40;
    phi_s0 = temp_s0_2;
    if (temp_s0_2 != 0x13E) {
        goto loop_9;
    }
    temp_s1_12 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_12 + 8);
    temp_s1_12->unk4 = 0;
    temp_s1_12->unk0 = 0xE7000000;
    temp_s1_13 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_13 + 8);
    temp_s1_13->unk4 = 0;
    temp_s1_13->unk0 = 0xE3000A01;
    temp_s1_14 = gDisplayListHead;
    gDisplayListHead = (void *) (temp_s1_14 + 8);
    temp_s1_14->unk0 = 0xE200001C;
    temp_s1_14->unk4 = 0x552078;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021764.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_80021CB4(s32 arg0, s32 arg1, s32 arg2) {
    if (func_8000B688(-2) != 0) {
        return 0;
    }
    return func_8000BD3C(-2, &D_8000B6B4, arg0, arg1, &D_80021764, arg2, 0, 0, 0, 0, 0, 0, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021CB4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
Failed to decompile function crash_screen_draw_rect:

Label L80021DB4_ovl0 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021D34.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
u32 func_80021E00(s32 arg0, s32 arg1, s32 arg2) {
    void *sp1C;
    s32 temp_a0;
    s32 temp_t0;
    u32 temp_t1;
    u32 temp_t2;
    u32 temp_v0;
    void *temp_a3;
    void *temp_v1;
    void *phi_a3;
    void *phi_v1;
    s32 phi_t0;

    temp_a3 = ((arg2 / 5) * 0x1C) + &D_8003F70C;
    sp1C = temp_a3;
    temp_t1 = 0x80000000U >> ((arg2 % 5) * 6);
    temp_t2 = temp_t1 >> 1;
    phi_a3 = temp_a3;
    phi_v1 = (osViGetCurrentFramebuffer(temp_a3) + ((D_8004A508 * arg1) * 2)) + (arg0 * 2);
    phi_t0 = 0;
loop_1:
    temp_a0 = *phi_a3;
    if ((temp_t1 & temp_a0) != 0) {
        *phi_v1 = (u16)0xFFFF;
    } else {
        *phi_v1 = (u16)1;
    }
    temp_v1 = phi_v1 + 2;
    if ((temp_t2 & temp_a0) != 0) {
        *temp_v1 = (u16)0xFFFF;
    } else {
        *temp_v1 = (u16)1;
    }
    temp_v0 = temp_t2 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = (u16)0xFFFF;
    } else {
        *temp_v1 = (u16)1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = (u16)0xFFFF;
    } else {
        *temp_v1 = (u16)1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = (u16)0xFFFF;
    } else {
        *temp_v1 = (u16)1;
    }
    temp_v0 = temp_v0 >> 1;
    temp_v1 = temp_v1 + 2;
    if ((temp_v0 & temp_a0) != 0) {
        *temp_v1 = (u16)0xFFFF;
    } else {
        *temp_v1 = (u16)1;
    }
    temp_t0 = phi_t0 + 1;
    phi_a3 = phi_a3 + 4;
    phi_v1 = ((temp_v1 + 2) + (D_8004A508 * 2)) - 0xC;
    phi_t0 = temp_t0;
    if (temp_t0 != 7) {
        goto loop_1;
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021E00.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_80021F80(s32 arg2) {
    return func_80033A40() + arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021F80.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void crash_screen_print(s32 arg0, ? arg1, ? arg2, ? arg3) {
    ? sp34;
    s32 temp_s0;
    s32 temp_v0;
    void *temp_t8;
    ? *phi_s1;
    s32 phi_s2;
    s32 phi_s0;

    temp_v0 = _Printf(&D_80021F80, &sp34, (s32) (sp + 0x14F) & -4);
    if (temp_v0 > 0) {
        if (temp_v0 > 0) {
            phi_s1 = &sp34;
            phi_s2 = arg0;
            phi_s0 = temp_v0;
loop_3:
            temp_t8 = &D_8003F68C + (*phi_s1 & 0x7F);
            if (*temp_t8 != 0xFF) {
                func_80021E00(phi_s2, arg1, *temp_t8);
            }
            temp_s0 = phi_s0 - 1;
            phi_s1 = phi_s1 + 1;
            phi_s2 = phi_s2 + 6;
            phi_s0 = temp_s0;
            if (temp_s0 != 0) {
                goto loop_3;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80021FA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_8002206C(s32 arg0) {
    u32 sp1C;
    u32 sp18;
    u32 temp_ret_3;
    u32 temp_ret_4;
    u32 temp_ret_5;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;
    u64 temp_ret;
    u64 temp_ret_2;

    temp_ret = func_8002DE08(arg0 >> 0x1F, arg0, 0, 0x3E8);
    temp_ret_2 = func_8002DE08(temp_ret, (u32) temp_ret, 0, 0xBB8);
    temp_ret_3 = func_8002DD08(temp_ret_2, (u32) temp_ret_2, 0, 0x40);
    temp_v1 = (u32) (u64) temp_ret_3;
    sp18 = temp_ret_3;
    sp1C = temp_v1;
    func_80035980(0, 0);
    temp_ret_4 = func_80034610();
    temp_v0 = temp_ret_4;
    if (sp18 >= temp_v0) {
        if ((((temp_v0 >= sp18) && ((u32) (u64) temp_ret_4 < sp1C)) && (temp_ret_5 = func_80034610(), temp_v0_2 = temp_ret_5, ((temp_v0_2 < sp18) == 0))) && (sp18 >= temp_v0_2)) {
block_5:
            if ((u32) (u64) temp_ret_5 < sp1C) {
                goto loop_3;
            }
        } else {
loop_3:
            temp_ret_5 = func_80034610();
            temp_v0_2 = temp_ret_5;
            if (temp_v0_2 < sp18) {
                goto loop_3;
            }
            if (sp18 >= temp_v0_2) {
                goto block_5;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_8002206C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022134(s32 arg2, void *arg3) {
    u32 temp_v1;

    temp_v1 = ((u32) (*arg3 & 0x7F800000) >> 0x17) - 0x7F;
    if ((s32) temp_v1 >= -0x7E) {
        if ((s32) temp_v1 < 0x80) {
block_3:
            crash_screen_print(&D_80040F14, arg2, (f64) *arg3);
            return;
        }
    }
    if (*arg3 == 0) {
        goto block_3;
    }
    crash_screen_print(0x80040F20, arg2, *arg3);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022134.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
s32 func_800221BC(s32 arg0) {
    u32 sp18;
    s32 temp_a3;
    s32 temp_v0;
    u32 phi_v1;
    s32 phi_v0;

    temp_a3 = arg0;
    sp18 = 0x20000U;
    arg0 = temp_a3;
    crash_screen_print(0x1E, 0x9B, &D_80040F2C, temp_a3);
    phi_v1 = 0x20000U;
    phi_v0 = 0;
loop_1:
    if ((arg0 & phi_v1) != 0) {
        return crash_screen_print(0x84, 0x9B, &D_80040F38, ((phi_v0 * 4) + 0x80040000)->unk-7AC);
    }
    temp_v0 = phi_v0 + 1;
    phi_v1 = phi_v1 >> 1;
    phi_v0 = temp_v0;
    if (temp_v0 != 6) {
        goto loop_1;
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800221BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
? func_80022248(s32 arg0, s32 arg1) {
loop_1:
    func_8002206C(0x10);
    func_8000464C();
    if (arg1 != 0) {
        if (osViGetCurrentFramebuffer() != arg1) {
            return 1;
        }
    }
    if (arg0 != D_80048F20) {
        goto loop_1;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022248.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800222C4(void *arg0, s32 arg1) {
    s32 temp_s2;
    s32 temp_s2_2;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_v0;
    u32 temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s1;
    void *temp_s1_2;
    s32 phi_s2;
    s32 phi_s2_2;
    void *phi_s0;
    s32 phi_s1;
    s32 phi_s2_3;

    temp_s2 = (s32) ((((u32) arg0->unk120 >> 2) & 0x1F) << 0x10) >> 0x10;
    phi_s2 = temp_s2;
    if (temp_s2 == 0x17) {
        phi_s2 = 0x10;
    }
    phi_s2_2 = phi_s2;
    if (phi_s2 == 0x1F) {
        phi_s2_2 = 0x11;
    }
    osWritebackDCacheAll();
    if (arg1 != 0) {
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0x19);
        if (arg1 != 2) {
            crash_screen_print(0x1E, 0x19, &D_80040F40, arg0->unk14, ((phi_s2_2 * 4) + 0x80040000)->unk-7F4);
        } else {
            crash_screen_print(0x1E, 0x19, &D_80040F50, arg0->unk14, &D_80040F60);
        }
        if (phi_s2_2 == 0) {
            crash_screen_print(0xA0, 0x19, &D_80040F6C, ((u32) arg0->unk120 >> 8) & 0xFF);
            crash_screen_print(0xD2, 0x19, &D_80040F78, 0xA4300008);
        }
        temp_s1 = arg0 + 0x20;
        crash_screen_print(0x1E, 0x23, &D_80040F84, temp_s1->unkFC, temp_s1->unkF8, temp_s1->unk104);
        osWritebackDCacheAll();
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
    }
    temp_s1_2 = arg0 + 0x20;
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    if (arg1 != 2) {
        crash_screen_print(0x1E, 0x19, &D_80040FA4, arg0->unk14, ((phi_s2_2 * 4) + 0x80040000)->unk-7F4);
    } else {
        crash_screen_print(0x1E, 0x19, &D_80040FB4, arg0->unk14, &D_80040FC4);
    }
    crash_screen_print(0x1E, 0x23, &D_80040FD0, temp_s1_2->unkFC, temp_s1_2->unkF8, temp_s1_2->unk104);
    if (phi_s2_2 == 0) {
        crash_screen_print(0xA0, 0x19, &D_80040FF0, ((u32) temp_s1_2->unk100 >> 8) & 0xFF);
        crash_screen_print(0xD2, 0x19, &D_80040FFC, 0xA4300008);
    }
    crash_screen_print(0x1E, 0x32, &D_80041008, temp_s1_2->unk4, temp_s1_2->unkC, temp_s1_2->unk14);
    crash_screen_print(0x1E, 0x3C, &D_80041028, temp_s1_2->unk1C, temp_s1_2->unk24, temp_s1_2->unk2C);
    crash_screen_print(0x1E, 0x46, &D_80041048, temp_s1_2->unk34, temp_s1_2->unk3C, temp_s1_2->unk44);
    crash_screen_print(0x1E, 0x50, &D_80041068, temp_s1_2->unk4C, temp_s1_2->unk54, temp_s1_2->unk5C);
    crash_screen_print(0x1E, 0x5A, &D_80041088, temp_s1_2->unk64, temp_s1_2->unk6C, temp_s1_2->unk74);
    crash_screen_print(0x1E, 0x64, &D_800410A8, temp_s1_2->unk7C, temp_s1_2->unk84, temp_s1_2->unk8C);
    crash_screen_print(0x1E, 0x6E, &D_800410C8, temp_s1_2->unk94, temp_s1_2->unk9C, temp_s1_2->unkA4);
    crash_screen_print(0x1E, 0x78, &D_800410E8, temp_s1_2->unkAC, temp_s1_2->unkB4, temp_s1_2->unkBC);
    crash_screen_print(0x1E, 0x82, &D_80041108, temp_s1_2->unkC4, temp_s1_2->unkCC, temp_s1_2->unkD4);
    crash_screen_print(0x1E, 0x8C, &D_80041128, temp_s1_2->unkDC, temp_s1_2->unkE4);
    func_800221BC(temp_s1_2->unk10C);
    func_80022134(0x1E, 0xAA, 0, temp_s1_2 + 0x114);
    func_80022134(0x78, 0xAA, 2, temp_s1_2 + 0x11C);
    func_80022134(0xD2, 0xAA, 4, temp_s1_2 + 0x124);
    func_80022134(0x1E, 0xB4, 6, temp_s1_2 + 0x12C);
    func_80022134(0x78, 0xB4, 8, temp_s1_2 + 0x134);
    func_80022134(0xD2, 0xB4, 0xA, temp_s1_2 + 0x13C);
    func_80022134(0x1E, 0xBE, 0xC, temp_s1_2 + 0x144);
    func_80022134(0x78, 0xBE, 0xE, temp_s1_2 + 0x14C);
    func_80022134(0xD2, 0xBE, 0x10, temp_s1_2 + 0x154);
    func_80022134(0x1E, 0xC8, 0x12, temp_s1_2 + 0x15C);
    func_80022134(0x78, 0xC8, 0x14, temp_s1_2 + 0x164);
    func_80022134(0xD2, 0xC8, 0x16, temp_s1_2 + 0x16C);
    func_80022134(0x1E, 0xD2, 0x18, temp_s1_2 + 0x174);
    func_80022134(0x78, 0xD2, 0x1A, temp_s1_2 + 0x17C);
    func_80022134(0xD2, 0xD2, 0x1C, temp_s1_2 + 0x184);
    func_80022134(0x1E, 0xDC, 0x1E, temp_s1_2 + 0x18C);
    osWritebackDCacheAll();
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    temp_s0 = temp_s1_2->unkD4;
    crash_screen_print(0x1A, 0x14, &D_8004113C, temp_s1_2->unkD4);
    phi_s0 = temp_s0;
    phi_s1 = 0x1E;
    phi_s2_3 = 0;
loop_17:
    temp_v1 = phi_s0->unk0;
    temp_v0 = ((u32) (temp_v1 & 0x7F800000) >> 0x17) - 0x7F;
    if (((s32) temp_v0 < -0x7E) || ((s32) temp_v0 >= 0x80)) {
        if (temp_v1 == 0) {
block_20:
            crash_screen_print(0x1A, phi_s1, &D_8004114C, phi_s2_3, (?32) (u8) phi_s0->unk0, (?32) phi_s0->unk1, (?32) phi_s0->unk2, (?32) phi_s0->unk3, (f64) (bitwise f32) phi_s0->unk0);
        } else {
            crash_screen_print(0x1A, phi_s1, &D_80041168, phi_s2_3, (?32) (u8) phi_s0->unk0, (?32) phi_s0->unk1, (?32) phi_s0->unk2, (?32) phi_s0->unk3, temp_v1);
        }
    } else {
        goto block_20;
    }
    temp_v1_2 = phi_s0->unk4;
    temp_s0_2 = phi_s0 + 4;
    temp_v0_2 = ((u32) (temp_v1_2 & 0x7F800000) >> 0x17) - 0x7F;
    if (((s32) temp_v0_2 < -0x7E) || ((s32) temp_v0_2 >= 0x80)) {
        if (temp_v1_2 == 0) {
block_25:
            crash_screen_print(0xAC, phi_s1, &D_80041184, temp_s0_2->unk0, (?32) temp_s0_2->unk1, (?32) temp_s0_2->unk2, (?32) temp_s0_2->unk3, (f64) (bitwise f32) temp_s0_2->unk0);
        } else {
            crash_screen_print(0xAC, phi_s1, &D_8004119C, temp_s0_2->unk0, (?32) temp_s0_2->unk1, (?32) temp_s0_2->unk2, (?32) temp_s0_2->unk3, temp_v1_2);
        }
    } else {
        goto block_25;
    }
    temp_s2_2 = phi_s2_3 + 8;
    phi_s0 = temp_s0_2 + 4;
    phi_s1 = phi_s1 + 0xA;
    phi_s2_3 = temp_s2_2;
    if (temp_s2_2 != 0x98) {
        goto loop_17;
    }
    osWritebackDCacheAll();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800222C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void *func_800229CC(void) {
    void *temp_v0;
    void *temp_v1;
    s32 phi_v0;
    void *phi_v1;

    temp_v0 = func_80034CF0();
    if (-1 != temp_v0->unk4) {
        phi_v0 = temp_v0->unk4;
        phi_v1 = temp_v0;
loop_2:
        if (phi_v0 > 0) {
            if (phi_v0 < 0xFF) {
                if ((phi_v1->unk12 & 3) != 0) {
                    return phi_v1;
                }
            }
        }
        temp_v1 = phi_v1->unkC;
        phi_v0 = temp_v1->unk4;
        phi_v1 = temp_v1;
        if (-1 != temp_v1->unk4) {
            goto loop_2;
        }
    }
    return NULL;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800229CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A38(s32 arg0) {
    *(void *)0x80096EF8 = arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A38.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A44(s32 arg0, ?32 arg1) {
    D_8003F86C = arg0;
    *(void *)0x8003F870 = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022A58(s32 arg0, ? arg1) {
    ? sp48;
    s32 temp_s3;
    s32 temp_t0;
    s32 temp_v0;
    u8 temp_v0_2;
    void *temp_t7;
    ? *phi_s4;
    s32 phi_s3;

    temp_v0 = _Printf(&D_80021F80, &sp48, arg0, arg1);
    if (temp_v0 > 0) {
        if (temp_v0 > 0) {
            phi_s4 = &sp48;
            phi_s3 = temp_v0;
loop_3:
            temp_v0_2 = *phi_s4;
            temp_t7 = &D_8003F68C + (temp_v0_2 & 0x7F);
            if (0xA == temp_v0_2) {
                D_8003F86C = 0x1E;
                D_8003F870 = (s32) (D_8003F870 + 0xA);
            } else {
                if (*temp_t7 != 0xFF) {
                    func_80021E00(D_8003F86C, D_8003F870, *temp_t7);
                }
                temp_t0 = D_8003F86C + 6;
                D_8003F86C = temp_t0;
                if ((D_8004A508 - 0x1E) < temp_t0) {
                    D_8003F86C = 0x1E;
                    D_8003F870 = (s32) (D_8003F870 + 0xA);
                }
            }
            temp_s3 = phi_s3 - 1;
            phi_s4 = phi_s4 + 1;
            phi_s3 = temp_s3;
            if (temp_s3 != 0) {
                goto loop_3;
            }
        }
    }
    osWritebackDCacheAll();
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022A58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022B88(s32 arg0, ? arg1, ? arg2, ? arg3) {
    func_80022A58((s32) (sp + 0x27) & -4);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022B88.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022BC4(s32 arg0) {
    ? sp34;
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_v0;

    osSetEventMesg(0xA, &D_80096ED8, 1);
    osSetEventMesg(0xC, &D_80096ED8, 2);
loop_1:
    osRecvMesg(&D_80096ED8, &sp34, 1);
    temp_v0 = func_800229CC();
    temp_s2 = temp_v0;
    if (temp_v0 == 0) {
        goto loop_1;
    }
    D_8003F688 = (u8)1;
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
    func_800222C4(temp_s2, 1);
    if (D_80096EF8 != 0) {
loop_3:
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
        func_80022A44(0x1E, 0x19);
        temp_s0 = D_80096EF8();
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        if (temp_s0 != 0) {
            func_800222C4(temp_s0, 0);
            func_80022248(0, 0);
            func_80022248(0x2030, 0);
        }
        func_800222C4(temp_s2, 0);
        goto loop_3;
    }
loop_6:
    goto loop_6;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022BC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022D98(void) {
    osCreateMesgQueue(&D_80096ED8, &D_80096EF0, 1);
    osCreateThread(&D_80096528, 8, &D_80022BC4, 0, &D_80096ED8, 0xFA);
    osStartThread(&D_80096528);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022D98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80022E04(s32 arg0) {
    ? sp4C;
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_s4;
    s32 temp_v0;
    s32 phi_s4;
    s32 phi_s0;
    s32 phi_s0_2;

    func_800009E8(&D_80096F00, &D_80096F10, &D_80096F08, 1);
    phi_s4 = sp48;
    phi_s0_2 = 0;
loop_1:
    osRecvMesg(&D_80096F10, &sp4C, 1);
    if (D_8003F688 != 0) {
        goto loop_1;
    }
    if (phi_s4 == D_8003DCA4) {
        phi_s0 = phi_s0_2 + 1;
    } else {
        phi_s0 = 0;
    }
    temp_s4 = D_8003DCA4;
    phi_s4 = temp_s4;
    phi_s0_2 = phi_s0;
    if (phi_s0 < 0x12C) {
        goto loop_1;
    }
    D_8003F688 = (u8)1U;
    temp_s2 = func_80033FC0(0);
    osSetThreadPri(0, 0xFA);
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
    func_800222C4(&D_80043DA0, 2);
    if (D_80096EF8 != 0) {
        func_80022248(0, 0);
        func_80022248(0x2030, 0);
        crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
        func_80022A44(0x1E, 0x19);
        temp_v0 = D_80096EF8();
        temp_s0 = temp_v0;
        if (temp_v0 != 0) {
            func_80022248(0, 0);
            func_80022248(0x2030, 0);
            func_800222C4(temp_s0, 0);
        }
    }
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    osSetThreadPri(0, temp_s2);
    D_8003F688 = (u8)0U;
    phi_s4 = temp_s4;
    phi_s0_2 = 0;
    goto loop_1;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80022E04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_80023048(void) {
    osCreateThread(&D_80096F28, 8, &D_80022E04, 0, &D_800978D8, 0x69);
    osStartThread(&D_80096F28);
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_80023048.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void fatal_printf(s32 arg0, ? arg1, ? arg2, ? arg3) {
    s32 sp20;
    s32 temp_s0;

    D_8003F688 = (u8)1;
    sp20 = func_80033FC0(0);
    osSetThreadPri(0, 0xFA);
    func_80022248(0, 0);
    func_80022248(0x2030, 0);
    func_80022248(0, 0);
    func_80022248(0x808, 0);
    func_80022248(0, 0);
    func_80022248(0x8200, 0);
    func_80022248(0, 0);
    func_80022248(0x4100, 0);
    func_80022248(0, 0);
    func_80022248(0x404, 0);
loop_1:
    temp_s0 = osViGetCurrentFramebuffer();
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0x19);
    func_80022A44(0x1E, 0x19);
    func_80022A58(arg0, (s32) (sp + 0x2F) & -4);
    if (func_80022248(0, temp_s0) != 0) {
        goto loop_1;
    }
    if (func_80022248(0x2030, temp_s0) != 0) {
        goto loop_1;
    }
    osSetThreadPri(0, sp20);
    D_8003F688 = (u8)0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/fatal_printf.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit e0e006e8858ba357d1dcb4dc64f038b7df278aa6
void func_800231F0(void *arg0) {
    s32 sp24;
    s32 temp_s0;

    D_8003F688 = (u8)1;
    sp24 = func_80033FC0(0);
    osSetThreadPri(0, 0xFA);
loop_1:
    temp_s0 = osViGetCurrentFramebuffer();
    crash_screen_draw_rect(0x19, 0x14, 0x10E, 0xD2);
    func_80022A44(0x1E, 0x19);
    arg0();
    if (func_80022248(0, temp_s0) != 0) {
        goto loop_1;
    }
    if (func_80022248(0x2030, temp_s0) != 0) {
        goto loop_1;
    }
    osSetThreadPri(0, sp24);
    D_8003F688 = (u8)0;
}
#else
GLOBAL_ASM("asm/non_matchings/ovl0/ovl0_8/func_800231F0.s")
#endif
